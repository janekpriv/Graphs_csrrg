\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{gray!10}, % Lekko szare tło
    commentstyle=\color{green},      % Kolor komentarzy
    keywordstyle=\color{blue},       % Kolor słów kluczowych
    stringstyle=\color{red},         % Kolor stringów
    basicstyle=\ttfamily\footnotesize, % Podstawowy styl tekstu
    breaklines=true,                 % Łamanie linii
    numbers=left,                    % Numeracja linii
    numberstyle=\tiny\color{gray},   % Styl numeracji linii
    frame=single,                     % Ramka wokół kodu
}
\lstset{style=mystyle}

\title{Dokumentacja funkcjonalna}
\author{Jan Michorek, Anastasiia Prodius}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{Wstęp}
Nasza aplikacja pozwala użytkownikowi wczytywać grafy z pliku 
o rozszerzeniu csrrg, a następnie dzielić graf na dowolną liczbę częśći.

\section{Technologie}
Aplikacja została zbudowana przy użyciu następujących technologii:
\begin{itemize}
    \item Język programowania: C
    \item Biblioteki: To be defined 

\end{itemize}

\section{Architektura systemu}
Aplikacja składa się z modułów:
\begin{itemize}
    \item Moduł generowania grafów
    \item Moduł analizy grafów
    \item Moduł wczytywania grafów z pliku
\end{itemize}

\section{Struktura kodu}
Kod źródłowy podzielony jest na następujące pliki i katalogi:
\begin{verbatim}
- src/
    - graph.c
    - csr_parser.c
- lib/
    - graph.h
    - csr_parser.h
- output/
\end{verbatim}


\section{Przykładowy kod}
Do przechowywania grafów, służą tak zdefiniowane struktury:
\begin{lstlisting}[language=C, caption=struktura grafu]
typedef struct Node {
    int id; // identyfikator wierszcholka, 0, 1, ..., n-1
    int deg; // stopien, czyli liczba krawedzi wierscholka z innymi
    struct Node **links; // wskaznik na sasiada
} *Node;

typedef struct Graph {
    int n; 
    int **mat; // macierz sąsiedstwa
    Node *nodes; // wskaznik na wierszcholek 0 w grafie
} Graph;
\end{lstlisting}
W bezpośredniej generacji grafów uczestniczą funkcję podane poniżej:
\begin{lstlisting}[language=C, caption=generacja]
void link_nodes(Node, Node);
Node create_Node(int);
Graph * graph_init(int);
Graph ** part_graphs(int parts, int margin);
\end{lstlisting}
Zczytywanie z pliku o rosrzerzeniu csrrg oraz zczytywanie z macierzy.
\begin{lstlisting}[language=C, caption=parsowanie i konwertowanie]
void parse_csrrg(FILE *in);
void parse_mat(FILE *in);
\end{lstlisting}

\section{Użycie}
Aplikacja jest uruchamiana z poziomu terminala, z parametrami podanymi w linii poleceń.
\begin{lstlisting}[language=bash, caption= Przykład uruchomienia programu w terminalu]
./partg graph.csrrg 3 20
\end{lstlisting}
gdzie 
\begin{itemize}
    \item \textbf{3} – liczba części, na które chcemy podzielić graf.
    \item \textbf{10} – margines, czyli dopuszczalna różnica w liczbie wierzchołków między podgrafami, wyrażona w procentach (wartość w zakresie od 0 do 100\%).
\end{itemize}

\textbf{Skrajne przypadki marginesu}:
\begin{itemize}
    \item \textbf{Margines 0\%}: Oznacza, że wszystkie podgrafy muszą mieć dokładnie tę samą liczbę wierzchołków, bez żadnej dopuszczalnej różnicy.
    \item \textbf{Margines 100\%}: Oznacza, że dopuszczalna różnica w liczbie wierzchołków między podgrafami może wynosić aż 100\% całkowitej liczby wierzchołków grafu, co daje pełną swobodę przy podziale (np. jeden podgraf może zawierać wszystkie wierzchołki, a inne podgrafy mogą być puste).
\end{itemize}

Jeśli nie podano tych parametrów, domyślnie graf będzie podzielony na \textbf{dwie części} z \textbf{marginesem 10\%}.

\section{Podsumowanie}
Aplikacja w podstawowej wersji zapewni użytkownikowi obsługę plików csrrg, i konwertowania sposobów zapisu grafów.

\end{document}
